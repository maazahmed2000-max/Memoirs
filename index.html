<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Memory Conversations - Share Your Stories with Maaz</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Nastaliq Urdu", "Noto Sans Arabic", Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            background: white;
            border-radius: 0;
            box-shadow: none;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            text-align: center;
            flex-shrink: 0;
            position: relative;
        }

        .header h1 {
            font-size: 1.3rem;
            margin-bottom: 5px;
        }

        .header p {
            opacity: 0.9;
            font-size: 0.85rem;
            display: none; /* Hide description to save space */
        }

        .header-toggle {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .header-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background: #f9f9f9;
            min-height: 0; /* Important for flex scrolling */
        }

        .message {
            margin-bottom: 20px;
            display: flex;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.user {
            justify-content: flex-end;
        }

        .message.ai {
            justify-content: flex-start;
        }

        .message-bubble {
            max-width: 70%;
            padding: 15px 20px;
            border-radius: 20px;
            word-wrap: break-word;
            line-height: 1.5;
        }

        .message.user .message-bubble {
            background: #667eea;
            color: white;
            border-bottom-right-radius: 5px;
        }

        .message.ai .message-bubble {
            background: #e3f2fd;
            color: #1976d2;
            border-bottom-left-radius: 5px;
        }

        .message[dir="rtl"] {
            direction: rtl;
        }

        .message[dir="rtl"] .message-bubble {
            text-align: right;
        }

        .input-area {
            padding: 15px;
            background: white;
            border-top: 2px solid #eee;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            flex-shrink: 0;
        }

        /* Main microphone button - prominent and centered */
        .btn-mic {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 3.5rem;
            padding: 30px;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-mic:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
        }

        .btn-mic.recording {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            animation: pulse 1.5s infinite;
            box-shadow: 0 6px 20px rgba(244, 67, 54, 0.5);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 6px 20px rgba(244, 67, 54, 0.5); }
            50% { transform: scale(1.1); box-shadow: 0 8px 30px rgba(244, 67, 54, 0.7); }
        }

        /* Typing input - secondary, collapsible */
        .input-group {
            width: 100%;
            max-width: 500px;
            display: flex;
            gap: 8px;
            opacity: 0.6;
            transition: opacity 0.3s;
            position: relative;
        }

        .input-group:hover,
        .input-group:focus-within {
            opacity: 1;
        }

        .input-group input {
            flex: 1;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 0.9rem;
            font-family: inherit;
            background: #f9f9f9;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
            background: white;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: normal;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn:hover {
            transform: translateY(-1px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-send {
            background: #4CAF50;
            color: white;
        }

        /* Toggle to show/hide typing input */
        .toggle-typing {
            font-size: 0.85rem;
            color: #666;
            cursor: pointer;
            text-decoration: underline;
            margin-top: -10px;
        }

        .toggle-typing:hover {
            color: #667eea;
        }

        .input-group.hidden {
            display: none;
        }

        .person-selector {
            padding: 10px 15px;
            background: #fff3cd;
            border-bottom: 2px solid #ffc107;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
            flex-shrink: 0;
            transition: max-height 0.3s ease, padding 0.3s ease, opacity 0.3s ease;
            overflow: hidden;
        }

        .person-selector.collapsed {
            max-height: 0;
            padding: 0;
            border-bottom: none;
            opacity: 0;
        }

        .person-selector label {
            font-weight: bold;
            font-size: 0.9rem;
            color: #856404;
        }

        .person-input-group {
            display: flex;
            gap: 10px;
            width: 100%;
            max-width: 400px;
        }

        .person-input-group input,
        .person-input-group select {
            flex: 1;
            padding: 10px 15px;
            border: 2px solid #ffc107;
            border-radius: 10px;
            font-size: 1rem;
            font-family: inherit;
        }

        .person-input-group input:focus,
        .person-input-group select:focus {
            outline: none;
            border-color: #ff9800;
        }

        .person-input-group button {
            padding: 10px 20px;
            background: #ff9800;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
        }

        .language-selector {
            padding: 8px 15px;
            background: #f5f5f5;
            display: flex;
            gap: 8px;
            justify-content: center;
            border-bottom: 2px solid #eee;
            flex-shrink: 0;
            transition: max-height 0.3s ease, padding 0.3s ease;
            overflow: hidden;
        }

        .language-selector.collapsed {
            max-height: 0;
            padding: 0;
            border-bottom: none;
        }

            .lang-btn {
            padding: 10px 20px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .lang-btn.active {
            background: #667eea;
            color: white;
        }

        .status {
            text-align: center;
            padding: 5px 10px;
            font-size: 0.8rem;
            color: #666;
            flex-shrink: 0;
            min-height: 25px;
        }

        .status.recording {
            color: #f44336;
            font-weight: bold;
        }

        .controls-toggle {
            position: fixed;
            bottom: 80px;
            right: 15px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s;
        }

        .controls-toggle:hover {
            transform: scale(1.1);
        }

        .controls-toggle.active {
            background: #764ba2;
        }

        @media (max-width: 600px) {
            .container {
                height: 100vh;
                border-radius: 0;
            }

            .header h1 {
                font-size: 1.1rem;
            }

            .message-bubble {
                max-width: 85%;
            }

            .chat-container {
                padding: 10px;
            }

            .controls-toggle {
                bottom: 70px;
                right: 10px;
                width: 45px;
                height: 45px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <button class="header-toggle" id="toggleControls" onclick="toggleControls()" title="Toggle controls">‚öôÔ∏è</button>
            <h1>üí¨ Memory Conversations with Maaz</h1>
            <p style="display: none;">Share your stories, memories, and experiences. I'm here to listen and remember.</p>
    </div>
    
        <div class="person-selector" id="personSelector">
            <label for="personInput">üë§ Who is sharing their memories?</label>
            <div class="person-input-group">
                <input type="text" id="personInput" placeholder="Enter your name" />
                <button id="setPersonBtn">Set</button>
            </div>
            <div id="currentPerson" style="margin-top: 5px; font-size: 0.9rem; color: #856404; font-weight: bold;"></div>
        </div>

        <div class="language-selector">
            <button class="lang-btn active" id="lang-en">English</button>
            <button class="lang-btn" id="lang-ur">ÿßÿ±ÿØŸà (Urdu)</button>
        </div>

        <div class="chat-container" id="chatContainer">
            <div class="message ai" id="welcomeMessage">
                <div class="message-bubble">
                    üë§ Please enter your name above to start. Each family member will have their own separate memory bank where all conversations are saved.
                </div>
            </div>
        </div>

        <div class="status" id="status">Tap the microphone to speak</div>

        <button class="controls-toggle" id="controlsToggle" onclick="toggleControls()" title="Show/Hide controls">‚öôÔ∏è</button>

        <div class="input-area">
            <button class="btn-mic" id="micBtn" title="Tap to speak">üé§</button>
            <div class="toggle-typing" id="toggleTyping">Or type instead</div>
            <div class="input-group hidden" id="inputGroup">
                <input type="text" id="messageInput" placeholder="Type your message..." />
                <button class="btn btn-send" id="sendBtn">Send</button>
        </div>
        </div>
    </div>

    <script>
        // Configuration
        // UPDATE THIS with your actual Cloudflare Worker URL
        // Find it at: https://dash.cloudflare.com ‚Üí Workers & Pages ‚Üí Your Worker
        const WORKER_URL = window.WORKER_URL || 'https://grandma-memory-worker.maazahmed2000.workers.dev';
        let currentLanguage = 'en-US';
        let sessionId = `session_${Date.now()}`;
        let conversationHistory = [];
        let isRecording = false;
        let currentRecognition = null;
        let responseDelayTimer = null;
        let pendingMessage = null;
        let currentSpeech = null; // Track current speech synthesis
        const RESPONSE_DELAY_MS = 2500; // Wait 2.5 seconds after user stops speaking before responding
        
        // Get person from URL parameter (for private invite links)
        // Example: ?person=grandma or ?personId=grandma
        const urlParams = new URLSearchParams(window.location.search);
        const urlPersonId = urlParams.get('person') || urlParams.get('personId');
        const urlPersonName = urlParams.get('name');
        
        // Set person from URL if provided, otherwise use localStorage
        let currentPersonId = urlPersonId || localStorage.getItem('currentPersonId') || 'default';
        let currentPersonName = urlPersonName || localStorage.getItem('currentPersonName') || '';
        
        // If person ID from URL, convert to name if name not provided
        if (urlPersonId && !urlPersonName) {
            // Convert person ID to readable name (e.g., "grandma" -> "Grandma")
            currentPersonName = urlPersonId.split('-').map(word => 
                word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
        }
        
        // Save to localStorage if set from URL
        if (urlPersonId) {
            localStorage.setItem('currentPersonId', currentPersonId);
            if (currentPersonName) {
                localStorage.setItem('currentPersonName', currentPersonName);
            }
        }

        // Speech Recognition Setup
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

        // DOM Elements
        const chatContainer = document.getElementById('chatContainer');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const micBtn = document.getElementById('micBtn');
        const statusDiv = document.getElementById('status');
        const langEnBtn = document.getElementById('lang-en');
        const langUrBtn = document.getElementById('lang-ur');
        const personInput = document.getElementById('personInput');
        const setPersonBtn = document.getElementById('setPersonBtn');
        const currentPersonDiv = document.getElementById('currentPerson');
        const toggleTyping = document.getElementById('toggleTyping');
        const inputGroup = document.getElementById('inputGroup');

        // Person/Profile Management
        function setPerson(name) {
            if (!name || !name.trim()) {
                alert('Please enter a name');
                return;
            }
            
            const personId = name.trim().toLowerCase().replace(/\s+/g, '-');
            currentPersonId = personId;
            currentPersonName = name.trim();
            
            // Save to localStorage
            localStorage.setItem('currentPersonId', currentPersonId);
            localStorage.setItem('currentPersonName', currentPersonName);
            
            // Update URL with person parameter (for bookmarking/sharing)
            const newUrl = new URL(window.location);
            newUrl.searchParams.set('person', personId);
            newUrl.searchParams.set('name', currentPersonName);
            window.history.replaceState({}, '', newUrl);
            
            // Update UI
            currentPersonDiv.textContent = `Currently: ${currentPersonName}`;
            personInput.value = '';
            
            // Hide person selector if person is set (cleaner UI)
            const personSelector = document.getElementById('personSelector');
            if (personSelector) {
                personSelector.classList.add('collapsed');
            }
            
            // Clear chat and load this person's history
            chatContainer.innerHTML = '';
            conversationHistory = [];
            sessionId = `session_${Date.now()}`;
            loadHistory();
            
            // Show welcome message for this person
            addMessage(
                `Hello ${currentPersonName}! I'm here to listen to your stories and memories for Maaz. Tell me about yourself, your life, your experiences - anything you'd like to share with Maaz. What would you like to talk about?`,
                'ai'
            );
        }

        setPersonBtn.addEventListener('click', () => {
            setPerson(personInput.value);
        });

        personInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                setPerson(personInput.value);
            }
        });

        // Note: We don't load other people's names for privacy
        // Each person only sees their own conversations

        // Language switching
        langEnBtn.addEventListener('click', () => {
            currentLanguage = 'en-US';
            langEnBtn.classList.add('active');
            langUrBtn.classList.remove('active');
            messageInput.placeholder = 'Type your message or use voice...';
        });

        langUrBtn.addEventListener('click', () => {
            currentLanguage = 'ur-PK';
            langUrBtn.classList.add('active');
            langEnBtn.classList.remove('active');
            messageInput.placeholder = 'ÿßŸæŸÜÿß Ÿæ€åÿ∫ÿßŸÖ Ÿπÿßÿ¶Ÿæ ⁄©ÿ±€å⁄∫ €åÿß ÿ¢Ÿàÿßÿ≤ ÿßÿ≥ÿ™ÿπŸÖÿßŸÑ ⁄©ÿ±€å⁄∫...';
        });

        // Send message
        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;
            sendMessageFromVoice(message);
            messageInput.value = '';
        }

        async function sendMessageFromVoice(message) {
            if (!message) return;

            // Check if person is set
            if (!currentPersonName || currentPersonId === 'default' || !currentPersonId || currentPersonId.trim() === '') {
                alert('Please enter your name first before sending messages.');
                const name = personInput.value || prompt('Enter your name:');
                if (name) {
                    setPerson(name);
                }
                return;
            }
            
            console.log('Sending message with personId:', currentPersonId, 'personName:', currentPersonName);

            // Clear any pending timers
            if (responseDelayTimer) {
                clearTimeout(responseDelayTimer);
                responseDelayTimer = null;
            }

            // Add user message to UI
            addMessage(message, 'user');
            messageInput.value = '';
            pendingMessage = null;
            
            // Update status
            statusDiv.textContent = 'AI is thinking...';
            statusDiv.classList.remove('recording');

            // Show typing indicator
            const typingId = addMessage('...', 'ai', true);

            try {
                // Send to chat API with person_id
                const response = await fetch(`${WORKER_URL}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message,
                        language: currentLanguage,
                        sessionId,
                        conversationHistory,
                        personId: currentPersonId
                    })
                });

                // Check if response is ok before parsing JSON
                if (!response.ok) {
                    const errorText = await response.text();
                    let errorMessage = `Server error (${response.status})`;
                    try {
                        const errorJson = JSON.parse(errorText);
                        errorMessage = errorJson.error || errorJson.details || errorMessage;
                    } catch (e) {
                        // Not JSON, use the text or status
                        errorMessage = errorText.substring(0, 100) || errorMessage;
                    }
                    throw new Error(errorMessage);
                }

                const result = await response.json();

                // Remove typing indicator
                removeMessage(typingId);

                if (result.success) {
                    // Add AI response
                    addMessage(result.response, 'ai');
                    
                    // Speak the AI response using text-to-speech
                    speakText(result.response);
                    
                    // Update conversation history
                    conversationHistory.push({
                        user: message,
                        ai: result.response
                    });
                    
                    // Reset status (will be updated by speakText when it finishes)
                                } else {
                    addMessage(`Sorry, I encountered an error: ${result.error || 'Unknown error'}. Please try again.`, 'ai');
                    statusDiv.textContent = 'Tap the microphone to speak';
                }
            } catch (error) {
                console.error('Error sending message:', error);
                console.error('Worker URL:', WORKER_URL);
                console.error('Error details:', error.message);
                removeMessage(typingId);
                
                let errorMsg = 'Connection error. ';
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    errorMsg += `Cannot connect to ${WORKER_URL}. Please check:\n1. Your internet connection\n2. The worker is deployed\n3. The worker URL is correct`;
                } else if (error.message.includes('CORS')) {
                    errorMsg += 'CORS error. The worker may not be allowing requests from this origin.';
                } else {
                    errorMsg += error.message || 'Please check your internet and try again.';
                }
                
                addMessage(errorMsg, 'ai');
                statusDiv.textContent = 'Tap the microphone to speak';
            }
        }

        // Add message to chat
        function addMessage(text, type, isTyping = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            if (currentLanguage === 'ur-PK') {
                messageDiv.setAttribute('dir', 'rtl');
            }
            
            const bubble = document.createElement('div');
            bubble.className = 'message-bubble';
            bubble.textContent = text;
            
            messageDiv.appendChild(bubble);
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;

            return isTyping ? messageDiv : null;
        }

        function removeMessage(messageDiv) {
            if (messageDiv) messageDiv.remove();
        }

        // Convert Hindi Devanagari script to Urdu Nastaliq script
        // This is needed because iOS speech recognition uses Hindi for Urdu
        function convertHindiToUrdu(hindiText) {
            if (!hindiText) return hindiText;
            
            // Check if text is already in Urdu/Arabic script - if so, return as-is
            const urduArabicPattern = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
            if (urduArabicPattern.test(hindiText)) {
                return hindiText; // Already in Urdu script
            }
            
            // Check if text contains Devanagari characters
            const devanagariPattern = /[\u0900-\u097F]/;
            if (!devanagariPattern.test(hindiText)) {
                return hindiText; // Not Devanagari, return as-is
            }
            
            // Common Devanagari to Urdu Nastaliq character mappings
            const devanagariToUrdu = {
                // Vowels
                '‡§Ö': 'ÿß', '‡§Ü': 'ÿ¢', '‡§á': 'ÿßŸê', '‡§à': 'ÿßŸê€å', '‡§â': 'ÿßŸè', '‡§ä': 'ÿßŸèŸà',
                '‡§è': '€í', '‡§ê': '€í', '‡§ì': 'Ÿà', '‡§î': 'Ÿà',
                // Consonants
                '‡§ï': '⁄©', '‡§ñ': '⁄©⁄æ', '‡§ó': '⁄Ø', '‡§ò': '⁄Ø⁄æ', '‡§ô': '⁄∫',
                '‡§ö': '⁄Ü', '‡§õ': '⁄Ü⁄æ', '‡§ú': 'ÿ¨', '‡§ù': 'ÿ¨⁄æ', '‡§û': '⁄∫',
                '‡§ü': 'Ÿπ', '‡§†': 'Ÿπ⁄æ', '‡§°': '⁄à', '‡§¢': '⁄à⁄æ', '‡§£': 'ŸÜ',
                '‡§§': 'ÿ™', '‡§•': 'ÿ™⁄æ', '‡§¶': 'ÿØ', '‡§ß': 'ÿØ⁄æ', '‡§®': 'ŸÜ',
                '‡§™': 'Ÿæ', '‡§´': 'Ÿæ⁄æ', '‡§¨': 'ÿ®', '‡§≠': 'ÿ®⁄æ', '‡§Æ': 'ŸÖ',
                '‡§Ø': '€å', '‡§∞': 'ÿ±', '‡§≤': 'ŸÑ', '‡§µ': 'Ÿà', '‡§∂': 'ÿ¥',
                '‡§∑': 'ÿ¥', '‡§∏': 'ÿ≥', '‡§π': '€Å', '‡§ï‡•ç‡§∑': '⁄©ÿ¥', '‡§§‡•ç‡§∞': 'ÿ™ÿ±', '‡§ú‡•ç‡§û': '⁄ØŸÜ',
                // Diacritics
                '‡§æ': 'ÿß', '‡§ø': 'Ÿê', '‡•Ä': '€å', '‡•Å': 'Ÿè', '‡•Ç': 'Ÿà', '‡•á': '€í', '‡•à': '€í', '‡•ã': 'Ÿà', '‡•å': 'Ÿà',
                '‡•ç': '', '‡§Ç': '⁄∫', '‡§É': '', '‡§º': ''
            };
            
            // Simple character-by-character conversion
            let urduText = '';
            for (let i = 0; i < hindiText.length; i++) {
                const char = hindiText[i];
                if (devanagariToUrdu[char]) {
                    urduText += devanagariToUrdu[char];
                } else {
                    urduText += char; // Keep non-Devanagari characters as-is (spaces, punctuation, etc.)
                }
            }
            
            return urduText || hindiText; // Return converted or original if conversion failed
        }

        // Text-to-Speech function for AI responses
        function speakText(text) {
            // Stop any current speech
            if (currentSpeech) {
                window.speechSynthesis.cancel();
            }
            
            // Check if speech synthesis is available
            if (!('speechSynthesis' in window)) {
                console.log('Text-to-speech not supported');
                return;
            }
            
            // Create speech utterance
            const utterance = new SpeechSynthesisUtterance(text);
            
            // Set language based on current language
            utterance.lang = currentLanguage === 'ur-PK' ? 'ur-PK' : 'en-US';
            
            // Set voice properties for natural, human-like speech
            utterance.rate = 0.92; // Slightly slower for natural conversation pace
            utterance.pitch = 1.05; // Slightly higher pitch for more warmth and human-like quality
            utterance.volume = 1.0;
            
            // Get available voices
            const voices = window.speechSynthesis.getVoices();
            
            if (currentLanguage === 'ur-PK') {
                // Priority order for Urdu voices (most natural first)
                const urduVoicePriorities = [
                    // Look for Urdu voices first
                    v => v.lang.startsWith('ur') && (v.name.includes('Neural') || v.name.includes('Premium') || v.name.includes('Enhanced')),
                    v => v.lang.startsWith('ur') && v.name.includes('Female'),
                    v => v.lang.startsWith('ur'),
                    // Fallback to Hindi voices (often better quality than basic Urdu)
                    v => v.lang.startsWith('hi') && (v.name.includes('Neural') || v.name.includes('Premium')),
                    v => v.lang.startsWith('hi') && v.name.includes('Female'),
                    v => v.lang.startsWith('hi')
                ];
                
                let selectedVoice = null;
                for (const priority of urduVoicePriorities) {
                    selectedVoice = voices.find(priority);
                    if (selectedVoice) break;
                }
                
                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                    utterance.lang = selectedVoice.lang; // Use the voice's actual language
                }
            } else {
                // Priority order for English voices (most natural/human-like first)
                const englishVoicePriorities = [
                    // Neural/premium voices (most natural)
                    v => v.lang.startsWith('en') && (v.name.includes('Neural') || v.name.includes('neural')),
                    // Premium/Enhanced voices
                    v => v.lang.startsWith('en') && (v.name.includes('Premium') || v.name.includes('premium')),
                    v => v.lang.startsWith('en') && (v.name.includes('Enhanced') || v.name.includes('enhanced')),
                    // Google's natural voices
                    v => v.lang.startsWith('en') && (v.name.includes('Google') && v.name.includes('Natural')),
                    // Microsoft's natural voices
                    v => v.lang.startsWith('en') && (v.name.includes('Microsoft') && (v.name.includes('Zira') || v.name.includes('Mark'))),
                    // Apple's high-quality voices (Siri-like)
                    v => v.lang.startsWith('en') && (v.name.includes('Samantha') || v.name.includes('Alex') || v.name.includes('Victoria')),
                    // Female voices (often sound more natural)
                    v => v.lang.startsWith('en-US') && v.name.includes('Female'),
                    v => v.lang.startsWith('en-US') && v.gender === 'female',
                    // Any en-US voice
                    v => v.lang.startsWith('en-US'),
                    // Any English voice as last resort
                    v => v.lang.startsWith('en')
                ];
                
                let selectedVoice = null;
                for (const priority of englishVoicePriorities) {
                    selectedVoice = voices.find(priority);
                    if (selectedVoice) {
                        console.log('Selected English voice:', selectedVoice.name, selectedVoice.lang);
                        break;
                    }
                }
                
                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                    utterance.lang = selectedVoice.lang;
                    // Adjust rate slightly based on voice type for more natural speech
                    if (selectedVoice.name.includes('Neural') || selectedVoice.name.includes('Natural')) {
                        utterance.rate = 0.95; // Neural voices can be slightly faster
                    }
                }
            }
            
            // Handle speech events
            utterance.onstart = () => {
                statusDiv.textContent = 'AI is speaking...';
            };
            
            utterance.onend = () => {
                statusDiv.textContent = 'Tap the microphone to speak';
                currentSpeech = null;
            };
            
            utterance.onerror = (event) => {
                console.error('Speech synthesis error:', event);
                statusDiv.textContent = 'Tap the microphone to speak';
                currentSpeech = null;
            };
            
            // Store reference and speak
            currentSpeech = utterance;
            
            // Load voices if not already loaded (some browsers need this)
            if (voices.length === 0) {
                window.speechSynthesis.onvoiceschanged = () => {
                    speakText(text); // Retry with loaded voices
                };
                    return;
                }

            window.speechSynthesis.speak(utterance);
        }

        // Speech Recognition
        function startSpeechRecognition() {
            if (!SpeechRecognition) {
                alert('Speech recognition not supported in your browser.');
                    return;
                }

            const recognition = new SpeechRecognition();
            // Use Hindi recognition for Urdu on iOS (iOS doesn't support Urdu directly)
            // The transcript will be converted from Devanagari to Urdu Nastaliq script
            recognition.lang = currentLanguage === 'ur-PK' ? 'hi-IN' : currentLanguage;
            recognition.continuous = false;
            recognition.interimResults = true;

            recognition.onstart = () => {
                // Stop any ongoing speech when user starts speaking
                if (currentSpeech) {
                    window.speechSynthesis.cancel();
                    currentSpeech = null;
                }
                
                isRecording = true;
                micBtn.classList.add('recording');
                statusDiv.textContent = 'Listening... Speak now';
                statusDiv.classList.add('recording');
                pendingMessage = null;
                // Clear any existing delay timer
                if (responseDelayTimer) {
                    clearTimeout(responseDelayTimer);
                    responseDelayTimer = null;
                }
            };

            recognition.onresult = (event) => {
                let transcript = '';
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    transcript += event.results[i][0].transcript;
                }
                
                // If using Urdu language, convert Hindi Devanagari to Urdu Nastaliq
                if (currentLanguage === 'ur-PK') {
                    transcript = convertHindiToUrdu(transcript);
                }
                
                messageInput.value = transcript;
                pendingMessage = transcript.trim();
                
                // Clear existing timer
                if (responseDelayTimer) {
                    clearTimeout(responseDelayTimer);
                }
                
                // If user is still speaking (interim results), wait
                const isFinal = event.results[event.results.length - 1].isFinal;
                if (isFinal && pendingMessage) {
                    // User stopped speaking, wait a bit before sending
                    statusDiv.textContent = 'Processing...';
                    responseDelayTimer = setTimeout(() => {
                        if (pendingMessage) {
                            sendMessageFromVoice(pendingMessage);
                            pendingMessage = null;
                        }
                    }, RESPONSE_DELAY_MS);
                }
            };

            recognition.onend = () => {
                isRecording = false;
                micBtn.classList.remove('recording');
                
                // If there's a pending message and no timer, send it immediately
                // (user manually stopped recording)
                if (pendingMessage && !responseDelayTimer) {
                    statusDiv.textContent = 'Processing...';
                    setTimeout(() => {
                        sendMessageFromVoice(pendingMessage);
                        pendingMessage = null;
                    }, 500);
                } else if (!pendingMessage) {
                    statusDiv.textContent = 'Tap the microphone to speak';
                    statusDiv.classList.remove('recording');
                }
            };

            recognition.onerror = (event) => {
                console.error('Recognition error:', event.error);
                isRecording = false;
                micBtn.classList.remove('recording');
                statusDiv.textContent = 'Error: ' + event.error;
            };

            recognition.start();
            currentRecognition = recognition;
        }

        // Toggle typing input visibility
        toggleTyping.addEventListener('click', () => {
            inputGroup.classList.toggle('hidden');
            if (!inputGroup.classList.contains('hidden')) {
                messageInput.focus();
                toggleTyping.textContent = 'Hide typing';
            } else {
                toggleTyping.textContent = 'Or type instead';
            }
        });

        // Event Listeners
        sendBtn.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                // Clear any pending delay timer
                if (responseDelayTimer) {
                    clearTimeout(responseDelayTimer);
                    responseDelayTimer = null;
                }
                sendMessage();
            }
        });

        micBtn.addEventListener('click', () => {
            if (isRecording && currentRecognition) {
                currentRecognition.stop();
                    } else {
                startSpeechRecognition();
            }
        });

        // Load conversation history on page load
        async function loadHistory() {
            try {
                // Load conversations for current person
                const response = await fetch(`${WORKER_URL}/conversations?personId=${currentPersonId}&limit=50`);
                const result = await response.json();
                
                if (result.success && result.conversations.length > 0) {
                    // Clear initial message
                    chatContainer.innerHTML = '';
                    
                    // Load conversations (they're already sorted by timestamp DESC, so reverse for display)
                    result.conversations.reverse().forEach(conv => {
                        addMessage(conv.user_message, 'user');
                        addMessage(conv.ai_response, 'ai');
                        conversationHistory.push({
                            user: conv.user_message,
                            ai: conv.ai_response
                        });
                    });
                }
            } catch (error) {
                console.error('Error loading history:', error);
            }
        }

        // Initialize - Auto-load if person is set via URL or localStorage
        if (currentPersonName && currentPersonId !== 'default') {
            // Update current person display
            currentPersonDiv.textContent = `Currently: ${currentPersonName}`;
            
            // Person is already set, load their history
            loadHistory();
            
            // Remove welcome message
            const welcomeMsg = document.getElementById('welcomeMessage');
            if (welcomeMsg) {
                welcomeMsg.remove();
            }
            
            // Hide person selector (they're already identified)
            const personSelector = document.getElementById('personSelector');
            if (personSelector) {
                personSelector.classList.add('collapsed');
            }
            // Auto-collapse controls when person is set
            if (typeof toggleControls === 'function' && controlsVisible) {
                toggleControls();
            }
            
            // Update URL to include person parameter (for bookmarking)
            const url = new URL(window.location);
            if (!url.searchParams.get('person')) {
                url.searchParams.set('person', currentPersonId);
                url.searchParams.set('name', currentPersonName);
                window.history.replaceState({}, '', url);
            }
        } else {
            // Show prompt if no person set
            currentPersonDiv.textContent = 'Please enter a name to start';
        }
    </script>
</body>
</html>

